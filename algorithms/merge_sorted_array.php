<?php

declare(strict_types=1);

/*   Даны два целочисленных массива nums1 и nums2, отсортированные в порядке возрастания,
и два целых числа m и n, представляющие количество элементов в nums1 и nums2 соответственно.
Объедините nums1 и nums2 в один массив, отсортированный в возврастающем порядке.
Окончательно отсортированный массив не должен возвращаться функцией, а должен храниться внутри массива nums1.
Чтобы учесть это, nums1 имеет длину m + n, где первые m
элементов обозначают элементы, которые следует объединить, а последние n элементов
имеют значение 0 и их следует игнорировать. nums2 имеет длину n.  */

class Solution
{

    /**
     * @param int[] $nums1
     * @param int $m
     * @param int[] $nums2
     * @param int $n
     * @return array
     */
    function merge(array &$nums1, int $m, array $nums2, int $n): array
    {
        $i = $m - 1; // Указатель для nums1
        $j = $n - 1; // Указатель для nums2
        $k = $m + $n - 1; // Указатель для позиции в nums1

        // Пока есть элементы в nums2
        while ($j >= 0) {
            if ($i >= 0 && $nums1[$i] > $nums2[$j]) {
                $nums1[$k] = $nums1[$i];
                $i--;
            } else {
                $nums1[$k] = $nums2[$j];
                $j--;
            }
            $k--;
        }
        return $nums1;
    }
}
$nums1 = [2, 2, 3, 0, 0, 0];
$m = 3;
$nums2 = [1, 5, 6];
$n = 3;

$solution = new Solution();
$solution->merge($nums1, $m, $nums2, $n);
print_r($nums1);


/*       Сравнение: Мы сравниваем элементы в nums1 и nums2 с конца, чтобы вставлять элементы в правильном порядке.
Обработка остатков: Если остались элементы в nums2, мы просто копируем их в nums1, так как они уже отсортированы.

Временная сложность: O(m + n) — мы проходим каждый массив один раз.
Пространственная сложность: O(1) — мы не используем дополнительную память, кроме переменных для указателей. */
