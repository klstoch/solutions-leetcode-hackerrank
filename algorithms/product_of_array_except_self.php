<?php

/*
 * Для заданного целочисленного массива 'nums' вернуть массив 'answer' , answer[i] равный произведению всех элементов, за nums исключением nums[i] .
 * Произведение любого префикса или суффикса 'nums' гарантированно помещается в 32-битное целое число .
 * Вам необходимо написать алгоритм, который выполняется вовремя  O(n) и без использования операции деления.
 */

declare(strict_types=1);

function productOfArrayExceptSelf(array $nums): array
{
    $length = count($nums);
    $answer = array_fill(0, $length, 1);

    // Заполняем массив произведений слева
    $leftProduct = 1;
    for ($i = 0; $i < $length; $i++) {
        $answer[$i] = $leftProduct; // Устанавливаем произведение слева
        $leftProduct *= $nums[$i]; // Обновляем левое произведение
    }

    // Заполняем массив произведений справа
    $rightProduct = 1;
    for ($i = $length - 1; $i >= 0; $i--) {
        $answer[$i] *= $rightProduct; // Умножаем на произведение справа
        $rightProduct *= $nums[$i]; // Обновляем правое произведение
    }

    return $answer;
}

/*
 * Объяснение:
Инициализация: Создаем массив answer и переменные leftProduct и rightProduct, инициализированные единицей.
               Первая итерация (слева направо):
                                               Заполняем массив answer, устанавливая произведение всех элементов слева от текущего индекса.
                                               Обновляем leftProduct на каждом шаге.
               Вторая итерация (справа налево):
                                               Умножаем значение в answer на произведение всех элементов справа от текущего индекса.
                                               Обновляем rightProduct на каждом шаге.
Временная и пространственная сложность:
Временная сложность: O(n), так как мы проходим массив дважды.
Пространственная сложность: O(n) поскольку мы используем дополнительный массив.
 */
$nums = [-1,1,0,-3,3];
$nums1 = [1, 2, 3, 4];
print_r(productOfArrayExceptSelf($nums1));